using System.Text;
using System.Linq; // needed for Select
using MetaModel.Example.Contracts;
using MetaModel.Example.Expressions;
using MetaModel.Example.Properties;

namespace MetaModel.Example.Compilation;

public static class CodeGenerator
{
    public static string GenerateScriptClass(ScriptNode script, string className = "GeneratedScript", string @namespace = "Generated")
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine($"namespace {@namespace};");
        sb.AppendLine($"public static class {className}");
        sb.AppendLine("{");
        sb.AppendLine("    // Variables storage (double only). Vector literals inline as arrays.");
        sb.AppendLine("    public static object Run(Dictionary<string,double> vars)");
        sb.AppendLine("    {");
        sb.AppendLine("        object __result = 0d;");
        int tempIndex = 0;
        foreach (var node in script.Children)
        {
            EmitNode(sb, node, ref tempIndex, "__result", "vars");
        }
        sb.AppendLine("        return __result;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    public static string GenerateExpression(INode node)
    {
        int tempIndex = 0;
        var sb = new StringBuilder();
        var expr = NodeToExpression(node, ref tempIndex, sb);
        // If there are side-effect lines (e.g., inline assignments) include them before the final expression
        if (sb.Length > 0)
        {
            sb.AppendLine(expr);
            return sb.ToString();
        }
        return expr;
    }

    private static void EmitNode(StringBuilder sb, INode node, ref int tempIndex, string resultVar, string varsName)
    {
        switch (node)
        {
            case AssignmentNode assign:
                {
                    var rhs = NodeToExpression(assign.Expression, ref tempIndex, sb, varsName);
                    sb.AppendLine($"        {varsName}[\"{assign.VariableName}\"] = {rhs};");
                    sb.AppendLine($"        {resultVar} = {varsName}[\"{assign.VariableName}\"]; ");
                    break;
                }
            case ConditionalNode cond:
                {
                    var condExpr = BoolConditionExpression(cond.Condition, ref tempIndex, sb, varsName);
                    sb.AppendLine($"        if ({condExpr})");
                    sb.AppendLine("        {");
                    var thenVal = NodeToExpression(cond.ThenBranch, ref tempIndex, sb, varsName);
                    sb.AppendLine($"            {resultVar} = {thenVal};");
                    sb.AppendLine("        }");
                    sb.AppendLine("        else");
                    sb.AppendLine("        {");
                    var elseVal = NodeToExpression(cond.ElseBranch, ref tempIndex, sb, varsName);
                    sb.AppendLine($"            {resultVar} = {elseVal};");
                    sb.AppendLine("        }");
                    break;
                }
            default:
                {
                    var expr = NodeToExpression(node, ref tempIndex, sb, varsName);
                    sb.AppendLine($"        {resultVar} = {expr};");
                    break;
                }
        }
    }

    private static string NodeToExpression(INode node, ref int tempIndex, StringBuilder sb, string varsName = "vars")
    {
        return node switch
        {
            NumberNode num => num.Value.ToString(System.Globalization.CultureInfo.InvariantCulture),
            VariableNode var => $"{varsName}.TryGetValue(\"{var.Name}\", out var __v{tempIndex}) ? __v{tempIndex++} : 0d",
            VectorNode vec => "new double[]{" + string.Join(",", vec.Components.Select(c => c.ToString(System.Globalization.CultureInfo.InvariantCulture))) + "}",
            AddNode add => Binary(add.Left, "+", add.Right, ref tempIndex, sb, varsName),
            SubtractNode sub => Binary(sub.Left, "-", sub.Right, ref tempIndex, sb, varsName),
            MultiplyNode mul => Binary(mul.Left, "*", mul.Right, ref tempIndex, sb, varsName),
            DivideNode div => Binary(div.Left, "/", div.Right, ref tempIndex, sb, varsName),
            AssignmentNode assign => EmitAssignmentInline(assign, ref tempIndex, sb, varsName),
            ConditionalNode cond => EmitConditionalInline(cond, ref tempIndex, sb, varsName),
            FunctionCallNode fn => EmitFunctionCall(fn, ref tempIndex, sb, varsName),
            ScriptNode script => EmitEmbeddedScript(script, ref tempIndex, sb, varsName),
            _ => "0d"
        };
    }

    private static string EmitAssignmentInline(AssignmentNode assign, ref int tempIndex, StringBuilder sb, string varsName)
    {
        var rhs = NodeToExpression(assign.Expression, ref tempIndex, sb, varsName);
        sb.AppendLine($"        {varsName}[\"{assign.VariableName}\"] = {rhs};");
        return $"{varsName}[\"{assign.VariableName}\"]";
    }

    private static string EmitConditionalInline(ConditionalNode cond, ref int tempIndex, StringBuilder sb, string varsName)
    {
        var conditionExpr = BoolConditionExpression(cond.Condition, ref tempIndex, sb, varsName);
        var thenExpr = NodeToExpression(cond.ThenBranch, ref tempIndex, sb, varsName);
        var elseExpr = NodeToExpression(cond.ElseBranch, ref tempIndex, sb, varsName);
        return $"({conditionExpr}) ? {thenExpr} : {elseExpr}";
    }

    private static string EmitFunctionCall(FunctionCallNode fn, ref int tempIndex, StringBuilder sb, string varsName)
    {
        var argList = new List<string>();
        foreach (var a in fn.Arguments)
        {
            argList.Add(NodeToExpression(a, ref tempIndex, sb, varsName));
        }
        return $"{fn.FunctionName}({string.Join(",", argList)})";
    }

    private static string EmitEmbeddedScript(ScriptNode script, ref int tempIndex, StringBuilder sb, string varsName)
    {
        var localResultName = $"__scriptRes{tempIndex}";
        sb.AppendLine($"        double {localResultName} = 0d;");
        foreach (var child in script.Children)
        {
            EmitNode(sb, child, ref tempIndex, localResultName, varsName);
        }
        return localResultName;
    }

    private static string Binary(INode left, string op, INode right, ref int tempIndex, StringBuilder sb, string varsName)
    {
        var l = NodeToExpression(left, ref tempIndex, sb, varsName);
        var r = NodeToExpression(right, ref tempIndex, sb, varsName);
        return $"({l} {op} {r})";
    }

    private static string BoolConditionExpression(INode condNode, ref int tempIndex, StringBuilder sb, string varsName)
    {
        return condNode switch
        {
            EqualNode eq => $"{NodeToExpression(eq.Left, ref tempIndex, sb, varsName)} == {NodeToExpression(eq.Right, ref tempIndex, sb, varsName)}",
            GreaterThanNode gt => $"{NodeToExpression(gt.Left, ref tempIndex, sb, varsName)} > {NodeToExpression(gt.Right, ref tempIndex, sb, varsName)}",
            _ => $"{NodeToExpression(condNode, ref tempIndex, sb, varsName)} != 0"
        };
    }
}
